# Default values for c3nav.
# This is a YAML-formatted file.

# common paramters

# Kubernetes Cluster Domain
clusterDomain: cluster.local

nameOverride: ""
fullnameOverride: ""


# c3nav settings to generate a c3nav.cfg file from.
# Most of the following settings will be ignored if c3navConfig or existingC3navConfigMap is set.
c3nav:
  # name is the instance name and defaults to .Release.Name if unspecified
  name: ""

  # debug enables the debug mode of all c3nav components
  debug: false
  # loglevel controls the loglevel of all c3nav components
  loglevel: info

  # tile rendering
  render_scale: "20.0"
  image_renderer: svg
  svg_renderer: rsvg
  cache_tiles: ""
  cache_resolution: "4"
  
  # artwork
  header_logo: ""
  favicon: ""
  favicon_package: ""

  # colors
  primary_color: "#00bb31"
  header_background_color: "#000000"
  header_text_color: "#ffffff"
  header_text_hover_color: "#eeeeee"
  msapplication_tile_color: "#da532c"
  safari_mask_icon_color: "{{ .Values.c3nav.primary_color }}"

  # imprint
  # imprint_address
  # imprint_patrons
  # imprint_team
  # imprint_hosting

  # initial map settings
  # initial_level
  # initial_bounds

  # map grid
  # grid_rows
  # grid_cols

  # tile_secret is the secret for signing authorization data passed to the tile servers. If left empty it's automatically generated.
  tile_secret: ""
  # tile_cache_server is the hostname of the external tileserver(s) to use. If empty the internal one is used.
  tile_cache_server: ""

  # session cookie domain is the domain for the session cookie. (Can be left untouched in most situations)
  session_cookie_domain: ""
  # tile access cookie domain is the domain for the tile access cookie. (Can be left untouched if no external tileserver is used)
  tile_access_cookie_domain: ""

  # wifi_ssids is the list of WiFi SSIDs to use for WiFi based positioning
  wifi_ssids: []

  # user_registration allows user registration
  user_registration: false

  # crs_proj4 is the proj4 projection config for converting GPS coordinates to the event space
  crs_proj4: ""

  # database config section
  database:
    # backend is the database backend to use. The use of postgresql is strongly recommended
    backend: postgresql
    # name is the database name, defaults to c3nav-{{ .Release.Name }} if empty
    name: ""
    # user is the database user, defaults to c3nav-{{ .Release.Name }} if empty
    user: ""
    # password is the database password, will be autogenerated if empty and bundeled postgres is used.
    password: ""
    # host ist the database hostname, will be autopopulated if empty and bundeled postgres is used.
    host: ""
    # port is the database port, will be autopopulated if empty and bundeled postgres is used.
    port: ""


  # django settings
  django:
    # django allowed hosts. defaults to domains setting
    # the kubernetes service name, pod ip, and localhost is automatically added at runtime
    allowed_hosts: []
    # secret is the DJANGO_SECRET config value. If left empty it's automatically generated.
    secret: ""
    # The Django STATIC_URL config value. Defaults to /static
    static_url: /static/
    # The Django MEDIA_URL config value. Defaults to /media/
    media_url: /media/
  
  # locale settings
  locale:
    # default locale
    default: en
    # backend timezone
    timezone: UTC
  
  # e-mail settings
  email:
    from: ""
    host: ""
    port: ""
    user: ""
    password: ""
    tls: false
    ssl: false
    admins: []
  
  memcached:
    # memcached connection string. Will be autopopulated if left empty and bundled memcached is used.
    location: ""
    # memcached username. Will be autopopulated if left empty and bundled memcached is used.
    username: ""
    # memcached password. Will be autogenerated if left empty and bundled memcached is used.
    password: ""

  redis:
    # redis connection string. Will be autopopulated if left empty and bundled redis is used.
    location: ""
    # redis password. Will be autogenerated if left empty and bundled memcached is used.
    password: ""

  # celery settings
  celery:
    # celery broker url. Will be autopopulated if left empty and bundled redis or rabbitmq is used.
    broker: 
    # celery backend url. Will be autopopulated if left empty and bundled redis is used.
    backend:

# The domains used for this c3nav instance.
# Defaults to {{ .Release.Name }}.c3nav.de if unset
domains: []
# The domains used for the tileservers of this c3nav instance.
# Defaults to tiles.{{ .Release.Name }}.c3nav.de if unset
tileserverDomains: []


# user provided c3nav config to use instead of generating one from the configured values
c3navConfig: ""
# extra configuration data to append to the generated c3nav config
c3navConfigExtra: ""
# use an existing ConfigMap for the c3nav config
existingC3navConfigMap: ""
# override the name of the ConfigMap created for the c3nav config
overrideC3navConfigMapName: ""
# the key containing the c3nav.cfg in the ConfigMap
c3navConfigKey: "c3nav.cfg"
# override the default c3nav config file path
overrideC3navConfigPath: ""

# use an existing secret for the c3nav secret
existingC3navSecret: ""
# override the name of the secret created for the c3nav
overrideC3navSecretName: ""
# the key containing the django secret in the c3nav secret
djangoSecretKey: "django_secret"
# the key containing the tile secret in the c3nav secret
tileSecretKey: "tile_secret"
# the key containing the memcached connection string in the c3nav secret
memcachedKey: "memcached"
# the key containing the redis connection string in the c3nav secret
redisKey: "redis"
# the key containing the redis password in the c3nav secret
redisPasswordKey: "redis-password"
# the key containing the celery broker url in the c3nav secret
celeryBrokerKey: "celery_broker"
# the key containing the celery backend url in the c3nav secret
celeryBackendKey: "celery_backend"
# the key containing the email (SMTP) username
emailUserKey: "email_user"
# the key containing the email (SMTP) password
emailPasswordKey: "email_password"

# use an existing secret for the database secret
existingDatabaseSecret: ""
# override the name of the secret created for the database credentials
overrideDatabaseSecretName: ""
# the key containing the database password in the database secret.
# Only used if bundeled postgres is not used or if existingDatabaseSecret is used.
databasePasswordKey: "database_password"

# use an existing secret for the memcached secret
existingMemcachedSecret: ""


image:
  # The registry to pull c3nav conatiners from
  registry: ghcr.io
  # The repository of the core container
  coreRepository: c3nav/c3nav
  # Optional override for the tiles pods. By default the same repository as for the core is used.
  tilesRepository: ""
  # Optional override for the workers pods. By default the same repository as for the core is used.
  workersRepository: ""
  # The repository of the tileserver container
  tileserverRepository: c3nav/c3nav-tileserver
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""
  pullPolicy: IfNotPresent
  pullSecrets: []

# c3nav core service
core:
  uwsgiWorkers: 4

  extraEnv: []

  podExtraAnnotations: {}

  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 500
    runAsGroup: 500
    fsGroup: 500
    fsGroupChangePolicy: OnRootMismatch

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  service:
    type: ClusterIP
    port: 80
  
  replicaCount: 1

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi
  
  persistence:
    enabled: true
    nameOverride: ""
    existingClaim: ""
    mountPath: /data
    subPath: ""
    storageClass: ""
    accessModes:
      - ReadWriteOnce
    size: 8Gi
    annotations: {}
    labels: {}

  metrics:
    ## Start a Prometheus exporter sidecar container for the core pod(s)
    enabled: false
    # uWSGI Exporter Prometheus Exporter image
    # ref: https://hub.docker.com/r/timonwong/uwsgi-exporter/tags
    image:
      registry: docker.io
      repository: timonwong/uwsgi-exporter
      tag: v1.3.0
      pullPolicy: IfNotPresent
      pullSecrets: []
    
    extraEnv: []

    securityContext:
      enabled: false
      runAsUser: 1001
    
    # Prometheus exporter service parameters
    service:
      # uWSGI Prometheus exporter service port
      port: 9117
      # Annotations for the Prometheus exporter service
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "{{ .Values.core.metrics.service.port }}"
    
    # uWSGI Prometheus exporter resource requests and limits
    resources:
      ## Example:
      ## limits:
      ##    cpu: 100m
      ##    memory: 128Mi
      limits: {}
      ## Examples:
      ## requests:
      ##    cpu: 100m
      ##    memory: 128Mi
      requests: {}

  # Pod affinity preset. Ignored if affinity is set. Allowed values: soft or hard
  podAffinityPreset: ""

  # Pod anti-affinity preset. Ignored if affinity is set. Allowed values: soft or hard
  podAntiAffinityPreset: "soft"

  nodeAffinityPreset:
    # Node affinity preset type. Ignored if affinity is set. Allowed values: soft or hard
    type: ""
    # Node label key to match Ignored if affinity is set.
    key: ""
    # Node label values to match. Ignored if affinity is set.
    values: []

  # Affinity for pod assignment
  affinity: {}

  # Node labels for pod assignment
  nodeSelector: {}

  # Tolerations for pod assignment
  tolerations: []


# c3nav task worker service
workers:
  extraEnv: []

  podExtraAnnotations: {}

  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 500
    runAsGroup: 500
    fsGroup: 500
    fsGroupChangePolicy: OnRootMismatch

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  replicaCount: 1

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  # Pod affinity preset. Ignored if affinity is set. Allowed values: soft or hard
  podAffinityPreset: ""

  # Pod anti-affinity preset. Ignored if affinity is set. Allowed values: soft or hard
  podAntiAffinityPreset: "soft"

  nodeAffinityPreset:
    # Node affinity preset type. Ignored if affinity is set. Allowed values: soft or hard
    type: ""
    # Node label key to match Ignored if affinity is set.
    key: ""
    # Node label values to match. Ignored if affinity is set.
    values: []

  # Affinity for pod assignment
  affinity: {}

  # Node labels for pod assignment
  nodeSelector: {}

  # Tolerations for pod assignment
  tolerations: []

# c3nav tile rendering service
tiles:
  # deploy seperate pod(s) for tile rendering. If set to false the core will take care of it.
  enabled: false

  uwsgiWorkers: 4

  extraEnv: []

  podExtraAnnotations: {}

  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 500
    runAsGroup: 500
    fsGroup: 500
    fsGroupChangePolicy: OnRootMismatch

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  service:
    type: ClusterIP
    port: 80
  
  replicaCount: 1

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi
  
  metrics:
    ## Start a Prometheus exporter sidecar container for the tiles pod(s)
    enabled: false
    # uWSGI Exporter Prometheus Exporter image
    # ref: https://hub.docker.com/r/timonwong/uwsgi-exporter/tags
    image:
      registry: docker.io
      repository: timonwong/uwsgi-exporter
      tag: v1.3.0
      pullPolicy: IfNotPresent
      pullSecrets: []

    extraEnv: []

    securityContext:
      enabled: false
      runAsUser: 1001
    
    # Prometheus exporter service parameters
    service:
      # uWSGI Prometheus exporter service port
      port: 9117
      # Annotations for the Prometheus exporter service
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "{{ .Values.tiles.metrics.service.port }}"
    
    # uWSGI Prometheus exporter resource requests and limits
    resources:
      ## Example:
      ## limits:
      ##    cpu: 100m
      ##    memory: 128Mi
      limits: {}
      ## Examples:
      ## requests:
      ##    cpu: 100m
      ##    memory: 128Mi
      requests: {}

  # Pod affinity preset. Ignored if affinity is set. Allowed values: soft or hard
  podAffinityPreset: ""

  # Pod anti-affinity preset. Ignored if affinity is set. Allowed values: soft or hard
  podAntiAffinityPreset: "soft"

  nodeAffinityPreset:
    # Node affinity preset type. Ignored if affinity is set. Allowed values: soft or hard
    type: ""
    # Node label key to match Ignored if affinity is set.
    key: ""
    # Node label values to match. Ignored if affinity is set.
    values: []

  # Affinity for pod assignment
  affinity: {}

  # Node labels for pod assignment
  nodeSelector: {}

  # Tolerations for pod assignment
  tolerations: []


# c3nav static files service
static:
  # deploy seperate pod(s) for serving static files. If set to false the core will take care of it.
  enabled: false

  image:
    registry: docker.io
    repository: bitnami/nginx
    tag: "1.25"
    pullPolicy: IfNotPresent
    pullSecrets: []

  extraEnv: []

  podExtraAnnotations: {}

  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 500
    runAsGroup: 0
    fsGroup: 500
    fsGroupChangePolicy: OnRootMismatch

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  service:
    type: ClusterIP
    port: 80
  
  replicaCount: 1

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  metrics:
    ## Start a Prometheus exporter sidecar container for the static files nginx
    enabled: false
    # NGINX Container Status Port scraped by Prometheus Exporter
    #  Defaults to specified http port
    port: ""
    # Bitnami NGINX Prometheus Exporter image
    # ref: https://hub.docker.com/r/bitnami/nginx-exporter/tags/
    image:
      registry: docker.io
      repository: bitnami/nginx-exporter
      tag: "0.11.0"
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []

    extraEnv: []

    securityContext:
      enabled: false
      runAsUser: 1001
    
    # Prometheus exporter service parameters
    service:
      # NGINX Prometheus exporter service port
      port: 9113
      # Annotations for the Prometheus exporter service
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "{{ .Values.static.metrics.service.port }}"
    
    # NGINX Prometheus exporter resource requests and limits
    resources:
      ## Example:
      ## limits:
      ##    cpu: 100m
      ##    memory: 128Mi
      limits: {}
      ## Examples:
      ## requests:
      ##    cpu: 100m
      ##    memory: 128Mi
      requests: {}

  # Pod affinity preset. Ignored if affinity is set. Allowed values: soft or hard
  podAffinityPreset: ""

  # Pod anti-affinity preset. Ignored if affinity is set. Allowed values: soft or hard
  podAntiAffinityPreset: "soft"

  nodeAffinityPreset:
    # Node affinity preset type. Ignored if affinity is set. Allowed values: soft or hard
    type: ""
    # Node label key to match Ignored if affinity is set.
    key: ""
    # Node label values to match. Ignored if affinity is set.
    values: []

  # Affinity for pod assignment
  affinity: {}

  # Node labels for pod assignment
  nodeSelector: {}

  # Tolerations for pod assignment
  tolerations: []


ingress:
  enabled: false
  className: ""
  annotations: {}
  # ingress hosts. Defaults to domains value if unset.
  hosts: []
  additionalHosts: []
  # enable tls.
  tls: true
  # custom tls config. If left empty a default config will automatically be created based on the domains setting.
  tlsConfig: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local
  # protect the ingress with http basic auth. Disabled if empty.
  # only works if className is set to traefik at the moment.
  basicAuth: {}
  #  someuser: "apr1 encrypted password hash"
  #  otheruser: "apr1 encrypted password hash"
  # alternativly an existing secret for http basic auth can be provided
  existingBasicAuthSecret: ""
  # override the name for the created basic auth secret
  basicAuthSecretNameOverride: ""
  # override the name of the basice auth middleware
  basicAuthMiddlewareNameOverride: ""


postgresql:
  enabled: true
  architecture: standalone
  auth:
    # defaults to c3nav-{{ .Release.Name }}
    database: "{{ printf \"c3nav-%s\" .Release.Name }}"
    # defaults to c3nav because it's not processed as a template
    username: c3nav

redis:
  enabled: true
  architecture: standalone
  auth:
    enabled: true
    # Will be autogenerated if left empty
    password: ""
    existingSecret: "{{ printf \"%s-c3nav-secret\" .Release.Name }}"
    existingSecretPasswordKey: "{{ include \"c3nav.redisPasswordKey\" . }}"

memcached:
  enabled: true
  auth:
    enabled: true
    # sadly the value of username is not evaluated as a template so we have to hardcode it
    username: c3nav
    # Will be autogenerated if left empty
    password: ""
    # The password generation of the bitnami memcached helm chart is broken.
    # So we disable the secret generation completely  and take care of it ourself.
    # Thankfully the value of existingPasswordSecret is evaluated as a template.
    existingPasswordSecret: "{{ include \"c3nav.memcachedSecretName\" . }}"


serviceAccount:
  # Specifies whether a service account should be created
  create: false
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""